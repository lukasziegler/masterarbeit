\section{Implementation}
\label{chapter:implementation}
\label{sec:implementation}
	% Chapter concerning the Technical Realization

	In this chapter we will deal with the infrastructure and technical realization of the public display survey platform. First, the requirements for the survey platform are discussed (section \ref{sec:implementation:requirements}). Subsequently the architecture resulting from the design decisions will be the main focus (section \ref{sec:implementation:design-decisions}). To facilitate the training period for successors we will also take a brief look at the software model (section \ref{sec:implementation:modeling}). For more specific information and for information regarding maintenance of the project, please refer to the documentation found on the CD enclosed or on the GitHub repository (see Appendix \ref{appendix:documentation}).

	In figure \ref{fig:4-pdsurvey-platform} a brief overview of the PDSurvey platform and its components is given. The platform consists of three major parts: a backend for display providers (PDAdmin), a RESTful server (PDServer) and the user interface itself, being embedded on the end user devices (public displays, tablets, smartphones or other devices). 






\subsection{Requirements}
\label{sec:implementation:requirements}

	The starting point for the PDSurvey platform, and the Master's thesis itself, was the official announcement\footnote{\url{http://www.medien.ifi.lmu.de/lehre/arbeiten/detail.xhtml-php?pub=alt_pdsurvey} (last visited on March 24, 2015)}, describing the scope of the thesis. This problem statement already included first requirements for the survey platform to develop, and was also a trigger for further literature review and talks with people from the industry.

	% Official Problem statement
	\begin{enumerate}[itemsep=0pt] 
	\item \textit{development of a survey tool} that allows interactive public display installations to be comprehensively assessed 
	\item a web-based survey platform will be implemented that can easily be used to evaluate and compare public displays through \textit{different channels} 
	\item \textit{different channels} to support: 1) evaluation directly at
	the display or 2) through a (mobile) website that allows participation via smartphone or tablet.
	\item \textit{configuration options} for public display owners
	\end{enumerate}

	Additional requirements, that have emerged during research and in discussions, are listed below:

	% Derived requirements
	\begin{itemize}[itemsep=0pt] 
	\item easy \textit{embedding of questionnaires} on websites of public display owners (provide API / embed code)
	\item support \textit{various devices}: public displays of all sizes, tablets, phablets, smartphones, desktop devices (responsive web design)
	\item allow for both \textit{quantitative and qualitative} metods of data collection
	\item easy \textit{scalability} of platform, host on a cloud platform
	\item use a \textit{modular approach}, allowing successors to extend and further refine the platform
	\item focus on \textit{public display evaluation}, take the context into account for evaluation
	\item furthermore design guidelines for the construction of public display applications introduced by Huang et al. \cite{huang2008overcoming} and Jacucci et al. \cite{jacucci2010worldsofinformation} were followed.
	\end{itemize}

	These requirements combined with knowledge from literature review, are what makes this platform unique. The long term goal is to create a research platform, optimized for public display evaluation, delivering new insights into how users react to public display setups. All of the mentioned requirements had an impact on the chosen architecture, will be discussed in the next section.



\subsection{Design Decisions}
\label{sec:implementation:design-decisions}

	After having assessed all requirements for the platform (see section \ref{sec:implementation:requirements}), the next step was making design decisions for the software, programming language and frameworks to use, before starting with the practical implementation of the platform. 

	Two weeks were taken for assessing all of the possibilities, on the one hand to get informed what is currently buzzing, on the other hand because every decision made has an impact on the architecture. Changing a technology half way through the project is not an option for the duration of this Master thesis.


	\paragraph{Programming language}

		Due to the requirements and objective to support a large number of devices, operating systems, and form factors, a device-independent programming language was preferred. 
		The choice fell on Javascript, not just due to the growing popularity\footnote{\url{http://www.sitepoint.com/javascript-internet-things/} (last visited on November 27, 2014)}, but also because it can be used on the largest number of platforms and devices. Another huge benefit is being able to only use JavaScript for all tiers of development, from client to server to persistence layer. Using the same language on all tiers allows us to share some parts of code between server and client. This approach has become very popular in recent years, now often being being encapsulated in a technology stack referred to as the MEAN stack, consisting of MongoDB, Express.js, Angular.js, and Node.js. Some fundamental differences to the LAMP stack (Linux, Apache, MySQL, PHP) are its shift form server-side to client-side single-page applications (SPA), faster prototyping, shift from synchronous to asynchronous, fast page loading times, less time spent writing SQL (schemaless), and the shift to using RESTful services for the backend\footnote{\url{http://www.ibm.com/developerworks/library/wa-mean1/index.html} (last visited on March 26, 2015)}. This already led for the first time to the thought of choosing the MEAN stack\footnote{\url{http://mean.io/} (last visited on March 26, 2015)} for the entire development. Nonetheless each part of the architecture was compared and evaluated separately, in order to find the optimal solution for this project.

		Alternative languages considered were: PHP, Python, Ruby, Java and ASP.NET. The biggest drawback was the additional workload on having to maintain the object model on multiple platforms. With Javascript it is possible to only having to maintain the object model once, easily keeping it consistent across all platforms (backend, frontend, server).

		Based on our requirements for the platform, the feedback received from discussions with industry experts, and the desire to be able to embed questionnaires on 3rd party website, the choice to use JavaScript for the whole development process already became evident. The still open question was whether to fully go along with the MEAN stack, or if it makes sense to replace Angular.js, Express.js or MongoDB with another solution..


	\paragraph{Frontend}

		The next question to be answered was which technologies to use in the frontend, leading to the question whether to follow the single-page application approach or not. As of 2014 JavaScript model-view frameworks most frequently used for creating single-page apps, are Angular.js, Ember.js and Backbone.js. When looking at the numbers and the trend from recent years, Angular.js is the clear favorite. It has by far the largest user base on GitHub, Stackoverflow, and Youtube. When comparing the number of third-party modules, Angular.js also takes the lead with 800 ngmodules vs. 236 Backbone.js backplugs vs. 21 emberaddons\footnote{\url{https://www.airpair.com/js/javascript-framework-comparison} (last visited on January 11, 2015)}. All these factors together indicate a short training time and give hope for making fast progress as beginners. 
		One of the biggest benefits of using a framework like Angular.js, is the ability to use two-way data-binding. Changes made to the model are automatically represented in the UI, and vice versa. Furthermore, the possibility to use the templating functionality, combined with the custom directives in Angular.js, was a big plus for this choice. This functionality was used for creating custom HTML tags for the question types in our surveys. These were amongst other the reasons why we chose Angular.js for this project, hoping that it will also simplify the ramp-up time for other students.

		To speed up frontend development we chose Bootstrap\footnote{\url{http://getbootstrap.com/} (last visited on December 1, 2014)} as our CSS framework of choice. Reasons for choosing Bootstrap were the large community, extensive documentation with helpful examples, large number of free tutorials and templates, its excellent integration with Angular.js (AngulatStrap\footnote{\url{http://mgcrea.github.io/angular-strap/}} and AngularUI), the short training time, and because it is so well established.
		Alternatives considered were Foundation Framework by Zurb, however at the time of writing there was no prefabricated integration for Foundation and Angular.js.
		A good overview\footnote{\url{http://www.sitepoint.com/5-most-popular-frontend-frameworks-compared/} (last visited on December 2, 2014)} and a comparison\footnote{\url{http://www.sitepoint.com/grid-system-comparison-bootstrap-vs-foundation/} (accessed March 24, 2015)} of currently popular frontend frameworks was also considered.

		% Express.js was chosen over Resty, simply due to its popularity and because it already suits the MEAN stack philosophy
	

	\paragraph{Backend}

		For the backend it was most important to have a solid and scalable solution with good performance, since our system might need to scale in the future, having a multiplicity of clients attached to the survey platform, all submitting responses and querying for different questionnaires. Additionally it was important to offer an administrator interface and to be able to easily exchange data with a large number of clients in a simple way. For this reason a backend built solely on the principles of a RESTful API was preferred, being able to use the same data on no matter which platform.
		% get curve to MEAN, say why we chose it now
		Based on the decision to use JavaScript for all tiers, it was also clear to use Node.js as the underlying platform for building web applications. Reasons speaking for Node.js are its event-based and modular approach, only requiring the parts needed for your project. Another benefit is the easy implementation of authentication or internationalization, due to the concept of middlewares \footnote{\url{http://www.heise.de/developer/artikel/REST-Webservices-mit-Node-js-Teil-1-Connect-als-Fundament-1802258.html?view=print} (last visited on November 24, 2014)} and the native serialization of JSON. Furthermore it is great for reusing code, due to its modular and lightweight architecture and the npm package manager. \footnote{\url{http://www.heise.de/developer/artikel/2x-Nein-4x-Ja-Szenarien-fuer-Node-js-2111050.html} and \url{http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-node-js} (both last accessed on April 9, 2015)}


		% Which framework to use
		The question which web framework to use for Node.js was not as straight forward to answer. A list of current options being Express.js, Conncet, Koa and Restify. 

		% + TODO compare these options
				+ say which one I chose why


		% Choosing Object Model ... Layer
		To facilitate the object modeling process Mongoose\footnote{\url{http://mongoosejs.com/} (accessed November 14, 2014)} was chosen. Mongoose is a object modeling package for Node.js, allowing to model the application data based on schemas. This simplifies making incremental changes to ... and keeping the model synchronized across all layers. 	Mongoose also takes care of performing CRUD applications.

		% Communication: RESTful interaction

		Due to the decision to build a single-page application it became vital to separate the data from presentation layer. Using a RESTful service is the current de facto standard. An alternative would be to use SOAP for message exchange, however leading to an increase of data overhead, more logic on server.side, and the loss of statelessness.

		% + TODO citation for REST vs SOAP

		Should a component not support HTML or JavaScript execution, then the required surveys can still be communicated directly with the REST API through rudimentary HTTP function calls, being another benefit for using a RESTful API.






	\paragraph{Database}

		Another fundamental aspect presented the question where to store the data persistently. Criteria for choosing the right database management system (DBMS) for this project were again the size of community, suitability for prototyping, and ease of integration with Node.js/Angular.js.

		The first question presented whether to choose a SQL or a NoSQL DBMS. Because NoSQL is better for rapid prototyping, its Schema can be mixed inside of one collection and develop over time. Combined with the benefit of having a better scalability, a schemaless data representation, faster response time and a decreased development time\cite{vaish2013getting}, these are all reasons speaking for using a NoSQL DBMS for our scenario. 

		Out of the NoSQL databases MondoDB\footnote{\url{http://www.mongodb.org/}} represents the most popular DBMS, especially since it integrates seamlessly into the MEAN stack. With the help of Mongoose, a object modeling package for Node.js, performing CRUD applications on MongoDB and maintaining a solid object model (schema) gets even easier.

		Benefits of MongoDB are being non-relational (and schemaless), plus its ability to directly store JavaScript object inside the database, being the biggest advantage. One disadvantage is that MongoDB does not support joins or transactions. For our use case, however, this is no major drawback. The benefits outweigh the disadvantages.


			% Reasons for using MongoDB
			% \begin{enumerate}
			% \item ideal for lots of write procedures
			% \item non-blocking write operations, ideal for Node.js and for logging data (good for our future work)
			% \item good read performance
			% \item good scalability
			% \item fully supports JSON syntax
			% \item good integration with Node.js, see Mongoose
			% \end{enumerate}

			% Notes from the MondoDB University M101JS Class
			% \begin{enumerate}
			% \item is non-relational, ideal for JSON data
			% \item MongoDB is schemaless. Two documents in the same collection can have different schemas.
			% \item MongoDB provides a good compromise between scalability/performance and the depth of funcitonality. MongoDB does not support Joins or Transactions
			% \end{enumerate}



		Alternatives looked at were CouchDB and Redis\footnote{\url{http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis} (accessed March 26, 2015)}. Redis being useful for fast changing data, which is not the case for our platform. CouchDB would be an alternative worth looking at, having a better replication and conflict resolution. This additional securitry is however not needed. The speed benefits of MongoDB, also being able to make dynamic queries, are preferred.



	\paragraph{Hosting}

		For the hosting of the platform a free and easy scalable solution was of importance. Our first choice was Heroku\footnote{https://www.heroku.com/}, due to its simplicity of setup, its native support of Node.js and the seamless integration with Mongolab\footnote{https://mongolab.com/}, hosting our MongoDB.

		% TODO: IaaS vs PaaS: https://www.youtube.com/watch?v=Q8jZHc0NS6A
		% give reasons why I chose PaaS (Platform as a Service)

		    % Heroku        PaaS
		    % IBM BlueMix   PaaS
		    % Amawon AWS    IaaS
		    % self hosting  IaaS

		    %   comparison  http://smashingboxes.com/ideas/heroku-vs-amazon-web-services


		Alternative were Google App Engine, IBM BlueMix, Amazon Web Services (Amazon EC2) or hosting everything on local or virtualized machines at our university. However for our scenario all of the above options had their drawbacks in comparison to Heroku. Google App Engine (as of December 2014) still had no native support for Node.js and custom runtimes had to be used to get Node.js support up and running. IBM BlueMix just got overhauled, offered full out-of-the-box Node.js support, however they only the first 30 days were free and the pricing model wasn't as attractive. Amazon Web Services offering a Infrastructure as a Service (IaaS), would have required too much administration of the server, which would have slowed down the main objective of the project, the development of the survey platform. The same goes for the last option, hosting a MEAN-stack environment on our own servers at LMU Munich. All of the above are well-known solutions in the industry, however due to simplicity and ease of use we chose Heroku.




		\paragraph{MEAN}
			In the end, as already predicted in the beginning, it turned out to be the classic MEAN stack. 

			The clear benefit, being able to use JavaScript from client to server to persistence level. 

			% give further reasons

			+ a fantastic short recap of the the last ten years of web development with an introduction to the MEAN stack, also explaining what the differences are between traditional web development (using the LAMP stack), to using the MEAN stack:
			\url{http://www.ibm.com/developerworks/library/wa-mean1/index.html} (last visited on March 26, 2015)



\clearpage
\input{4c_modeling}
\label{sec:implementation:modeling}


	% FIRST OUTLINE

		% Modeling
		% 	Software Model
		% 	+ Dependencies in between them
		% 	Users
		% 	User Stories
		% 	REST API


